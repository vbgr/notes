# Concurrent Objects

## Main definitions

● **Definition 1. Blocking operation.** An operation is called *blocking* if delay in its execution causes delays in other threads. Otherwise the operation is *nonblocking*.

● **Definition 2. Event.** An *event* in a program execution is either $inv(P, O, M, A)$ or $ret(P, O, M, R)$ where:

  * P - process ID
  * O - object ID
  * A - operation arguments
  * R - operation results

● **Definition 3. History.** History - finite sequence of events.

Example:

$$
H = \{ inv(1, q, deq, ), inv(2, q, enq, a), ret(2, q, enq, ), inv(3, q, enq, b) \}
$$

The following naming conventions are used below:

* $len(H)$ - history length
* $H[i]$ - i-th event
* $e.p$ - event's process id
* $e.o$ - event's object id
* $e.f$ - event's operation id
* $inv?(e)$ - claim that event $e$ is an invocation event
* $ret?(e)$ - claim that event $e$ is a return event
* $Ret!$ - set of returns

● **Definition 4. Matching pair.** Let $H$ be a history, positions $m, n \in 1 .. len(H)$ form a *matching pair* denoted $mp(m, n, H)$, if and only if
$$0 < m < n \le len(H) \land H[m].p = H[n].p \land H[m].o = H[n].o \land H[m].f = H[n].f \land$$
$$\land \forall k: m < k < n \implies H[k].p \ne H[n].p$$

Matching pair represents a single function call (operation).

● **Definition 5. Pending invocation.** Position $n$ in history $H$ is a *pending invocation* denoted $pi(n, H)$, if and only if
$$1 \le n \le len(H) \land inv?(H[n]) \land \forall m: n < m \le len(H) \implies H[m].p \ne H[n].p$$

e.g. there is no matching return event for the given invocation event.

● **Definition 6. Sequential history.** History $H$ is *sequential* if all its invocation events are immediately followed by their matching returns.

● **Definition 7. Legal history.** History $H$ is *legal*, denoted $legal(H)$, if and only if

$$\forall n \in 1 .. len(H): (inv?(H[n]) \implies pi(n,H) \lor \exists m \in 1 .. len(H): mp(n, m, H)) \lor (ret?(h[n]) \implies \exists m \in 1 .. len(H): mp(m, n, H))$$

● **Definition 8. Complete history.** Let $H$ be a history, then
$$complete(H) = \{ H[m]: \forall m \in 1 .. len(H) \land \exists n \in 1 .. len(H): mp(m, n, H)\}$$

e.g. $complete(H) \subset H$ - subset of complete methods.

● **Definition 9. Quiescent history.** A legal history $H$ is *quiescent*, denoted $qu(H)$, if
$$\forall n \in 1 .. len(H): \lnot pi(n, H)$$

e.g. a history $H$ is *quiescent* $\iff$ $complete(H) = H$.

● **Definition 10. Process subhistory.** $H|_{P} = \{ e \in H: e.p = P \}$.

● **Definition 11. Object subhistory.** $H|_{O} = \{ e \in H: e.o = O \}$.

● **Definition 12. Well-formed history.** A history $H$ is *well-formed**, if and only if $H|_{P}$ is sequential for each process $P$.

● **Definition 13. History equivalence.** A history $H_1$ is equivalent to history $H_2$, denoted $H_1 \sim H_2$, if and only if $H_1|_P = H_2|_P$ for each process P.

● **Definition 14. Method call interval.** Let $1 \le m < n \le len(H) \land inv?(H[m]) \land ret?(H[n])$ then $\{ H[i]: i \in [m, n] \}$ - interval of the method call $H[m]$.

● **Definition 15. Concurrent method calls.** Two methods calls are *concurrent* if their intervals overlap.

● **Definition 16. Preceding methods calls.** A method call $m_0$ *precedes* the method call $m_1$ in history $H$ if $m_0$ returns before $m_1$ execution starts in history $H$, denoted $m_0 \rightarrow _H m_1$.

## Linearizability

● **Lemma 1.** In finitie set $X$ with partial order there exists at least one maximal element $x \in X: \forall y \in X \lnot x \rightarrow y$.
▶
Proof scetch. If there is no maximal element in $X$ then we can take any $x_1 \in X$ and find $x_2 \in X: x_1 \rightarrow x_2$. For $x_2$ we will find a greater $x_3$ and so we form an infinite sequence. This contradicts with the claim that $X$ is finite.
◀

● **Definition 17. Linearization.** A legal sequential history $S$ is *linearization* of a history $H$ if $H$ can be extended to $H'$ by appending zero or more responses such that:

* **L1** $complete(H') \sim S$
* **L2** $m_0 \rightarrow _H m_1 \implies m_0 \rightarrow _S m_1$

$H$ is linearizable if there is a linearization of $H$.

In a more formal way the definition looks like: $\exists f: 1 .. len(H) \leftrightarrow 1 .. len(S): (\forall n: 1.. len(H): H[n] = S[f(n)]) \land  (\forall m, n: mp(m, n) \implies f(m) + 1 = f(n)) \land (\forall m < n < m' < n' \in 1 .. len(H): inv?(H(m)) \land ret?(H(n)) \land inv?(H(m')) \land ret?(H(n')) \land mp(m, n, H) \land mp(m', n', H) \implies f(n) < f(m'))$.

● **Theorem 1.** A history $H$ is linearizable $\iff$ $H|_x$ is linearizable for each object $x$.
▶ $\Leftarrow$. Let $R_x$ be a set of responses added to $H|_x$ to construct a linearization of $H|_x$, let's denote $H'|_x = H|_x \cup R_x$. Let $H'=H \cup (\bigcup_{x} R_x)$. We proof that $H|_x \text{ is linearizable} \implies H \text{ is linearizable}$ by induction by $len(H')$.
If $len(H') = 0$ we are done. Let's assume the claim for every $H_1'$ where $len(H_1') < k$. $H|_x$ is linearizable history for each $x$, let's denote $S_x$ - linearization of $H|_x$. Each $S_x$ is sequential and finite, because of that there is last method in each $S_x$ with respect to the order $\rightarrow _{S_{x}}$. One of these methods must be a maximal method $m$ with respect to the order $\rightarrow _H$. Let's denote $G'=H' \setminus \{ m \}$, then $H'=G'.m$, where $.$ mean concatenation. By induction claim $len(G') < len(H') = k \implies G' \text{ is linearizable}$. Let's denote $Q'$ - linearization of $G'$, then $Q'.m$ will be linearization of $H$ because of the property L2. 
$\Rightarrow$. Let's denote $S$ - linearization of $H$, we need to proof that $S|_x$ is linearization of $H|_x$ for any object $x$ in history $H$. 
* $S \text{ is sequential} \implies S|_x \text{ is sequential } \forall x$ because $S|_x \subset S$.
* $complete(H') \sim S \implies complete(H')|_P = S|_P \forall P \implies complete((H'|_P)|_x) = (S|_P|)_x \forall x \implies complete(H'|_x) \sim S|_x$.
* $(m_0 \rightarrow _H m_1 \implies m_0 \rightarrow _S m_1) \implies (m_0 \rightarrow _{H_x} m_1 \implies m_0 \rightarrow _{S_x} m_1)$

therefore $S_x$ is linearization of $H_x$.◀ 

## Quiescent consistency

● **Definition 18. Quiescent consistency** Let $H$ be a history and $S$ is a sequential history. $H$ is *quiescently consistent* with $S$ $\iff$ $\exists f: H \leftrightarrow S \text{ such that } \forall m,n \in 1 .. len(H) : mp(m, n, H) \implies f(m) + 1 = f(n) \land \forall m < k \le n:  ret?(H[m]) \land inv?(H[n]) \land complete(H[1..k]) = H[1..k] \implies f(m) < f(n)$.
$H$ is *quiescently consistent* if there is such $S$ for it.

● **Theorem 2.** Let $H$ be a history, $H|_x$ is quiescently consistent for every object $x$ $\implies$ $H$ is quiescently consistent.
▶ Let $R_x$ be a set of responses added to $H|_x$ to make it complete, $H'|_x = H|_x \cup R_x$, $H'=H \cup (\bigcup_{x} R_x)$. We proof that $H|_x \text{ is quiescently consistent} \implies H \text{ is quiescently consistent}$ by induction by $K = len(H')$.
If $len(H') = 0$ we are done. Let's assume the claim for every $H_1'$ where $len(H_1') < K$. Let's denote $k = max\{ 1 \le k < len(H'): complete(H'[1..k] = H'[1..k]) \}$, if there is no such $k$ we can make sequential history from $H'$ by applying any order to the methods of $H'$, because then there is no quiescent period in $H'$ and we are done. If there is such $k$ then by the induction claim $G'=H'[1..k]$ is quiescently consistent with a history $Q'$ because $len(G') < K$. The tail $H'[k..]$ has not quiescent periods and because of that $H'$ is quiescently consistent with $S'=Q'.m_{i_1}..m_{i_t}$ where $m_{i_1}...m_{i_t}$ - all methods of $H[k..]$ in any order.

Example of execution which is quiescently consistent in total but separate objects histories may be not quiescently consistent:

```
          r.write(1)
P0: ┈┈┈┈┈┈[━━━━]┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈→

        q.write(1)
P1: ┈┈┈[━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━]┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈→

             r.read(1)
P2: ┈┈┈┈┈┈┈┈┈┈[━━━━]┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈→

                          r.read(0)
P3: ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈[━━━━]┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈→
```


Example of a quiescently consistent execution:

```
             q.enq(x)           q.deq(y)
P0: ┈┈┈┈┈┈┈┈┈[━━━━━━]┈┈┈┈┈┈┈┈┈┈┈[━━━━━━]┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈→

                        q.enq(y)             q.deq(x)
P1: ┈┈┈┈┈┈┈┈┈┈┈┈┈[━━━━━━━━━━━━━━━━━━]┈┈┈┈┈┈┈┈[━━━━━━]┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈→
```

## Sequential consistency

● **Definition 19. Sequential consistency** Let $H$ be a concurrent history and $S$ is sequential history. The history $H$ said to be sequential consistent with $S$ $\iff$ $\exists f: H \leftrightarrow S: H[n] = S[f(n)] \land \forall 1 \le m < n \le len(H) \implies f(m) + 1 = f(n) \land H|_P = S|_P \forall P$

Example:

```
             q.enq(x)         q.deq(y)
P0: ┈┈┈┈┈┈┈┈┈[━━━━━━]┈┈┈┈┈┈┈┈┈[━━━━━━]┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈→

                          q.enq(y)
P1: ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈[━━━━━━]┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈→
```

The execution above is intuitive incorrect but from formal definition point of view it's sequentially consistent.

● Sequential consistency is not compositional. This follows from the following example:

```
      p.enq(x)          q.enq(x)          p.deq(y)
P0: ┈┈[━━━━━━]┈┈┈┈┈┈┈┈┈┈[━━━━━━]┈┈┈┈┈┈┈┈┈┈[━━━━━━]┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈→

               q.enq(y)          p.enq(y)           q.deq(x)
P1: ┈┈┈┈┈┈┈┈┈┈┈[━━━━━━]┈┈┈┈┈┈┈┈┈┈[━━━━━━]┈┈┈┈┈┈┈┈┈┈┈[━━━━━━]┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈→
```

Example of quiescently consistent but not sequentially consistent execution:

```
      p.enq(x)   q.enq(x)                p.deq(y)
P0: ┈┈[━━━━━━]┈┈┈[━━━━━━━━━━━━]┈┈┈┈┈┈┈┈┈┈[━━━━━━]┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈→

         q.enq(y)          p.enq(y)           q.deq(x)
P1: ┈┈┈┈┈[━━━━━━━━━━━━]┈┈┈┈[━━━━━━]┈┈┈┈┈┈┈┈┈┈┈[━━━━━━]┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈→
```

Example of sequentially consistent but not quiescently consistent execution:

```
                   q.enq(y)        q.deq(y)
P0: ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈[━━━━━━]┈┈┈┈┈┈┈┈[━━━━━━]┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈→

        q.enq(x)
P1: ┈┈┈┈[━━━━━━]┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈→
```

Example of sequentially and quiescently consistent execution:

```
      r.read(1)
P0: ┈┈[━━━━━━]┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈→

         r.write(1)        r.read(2)
P1: ┈┈┈┈┈[━━━━━━━━━━━━]┈┈┈┈[━━━━━━]┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈→

       r.write(2)
P2: ┈┈[━━━━━━]┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈→
```

## References

1. Quiescent Consistency: Defining and Verifying Relaxed Linearizability. John Derrick, Brijesh Dongol, Gerhard Schellhorn, Bogdan Tofan, Oleg Travkin, Heike Wehrheim. 2014.
2. The Art of Multiprocessor Programming. 2nd edition. Maurice Herlihy, Nir Shavit, Victor Luchangco, Michael Spear. 2021.
